Index: jtag_tap/rtl/verilog/tap_defines.v
===================================================================
--- jtag_tap.orig/rtl/verilog/tap_defines.v
+++ /dev/null
@@ -1,66 +0,0 @@
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-////  tap_defines.v                                               ////
-////                                                              ////
-////                                                              ////
-////  This file is part of the JTAG Test Access Port (TAP)        ////
-////  http://www.opencores.org/projects/jtag/                     ////
-////                                                              ////
-////  Author(s):                                                  ////
-////       Igor Mohor (igorm@opencores.org)                       ////
-////                                                              ////
-////                                                              ////
-////  All additional information is avaliable in the README.txt   ////
-////  file.                                                       ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-////                                                              ////
-//// Copyright (C) 2000 - 2003 Authors                            ////
-////                                                              ////
-//// This source file may be used and distributed without         ////
-//// restriction provided that this copyright statement is not    ////
-//// removed from the file and that any derivative work contains  ////
-//// the original copyright notice and the associated disclaimer. ////
-////                                                              ////
-//// This source file is free software; you can redistribute it   ////
-//// and/or modify it under the terms of the GNU Lesser General   ////
-//// Public License as published by the Free Software Foundation; ////
-//// either version 2.1 of the License, or (at your option) any   ////
-//// later version.                                               ////
-////                                                              ////
-//// This source is distributed in the hope that it will be       ////
-//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
-//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
-//// PURPOSE.  See the GNU Lesser General Public License for more ////
-//// details.                                                     ////
-////                                                              ////
-//// You should have received a copy of the GNU Lesser General    ////
-//// Public License along with this source; if not, download it   ////
-//// from http://www.opencores.org/lgpl.shtml                     ////
-////                                                              ////
-//////////////////////////////////////////////////////////////////////
-//
-// CVS Revision History
-//
-// $Log: not supported by cvs2svn $
-// Revision 1.2  2004/01/27 10:00:33  mohor
-// Unused registers removed.
-//
-// Revision 1.1  2003/12/23 14:52:14  mohor
-// Directory structure changed. New version of TAP.
-//
-//
-//
-
-
-// Length of the Instruction register
-`define	IR_LENGTH	4
-
-// Supported Instructions
-`define EXTEST          4'b0000
-`define SAMPLE_PRELOAD  4'b0001
-`define IDCODE          4'b0010
-`define DEBUG           4'b1000
-`define MBIST           4'b1001
-`define BYPASS          4'b1111
-
Index: jtag_tap/rtl/verilog/tap_top.v
===================================================================
--- jtag_tap.orig/rtl/verilog/tap_top.v
+++ jtag_tap/rtl/verilog/tap_top.v
@@ -98,7 +98,6 @@
 // synopsys translate_off
 `include "timescale.v"
 // synopsys translate_on
-`include "tap_defines.v"
 
 // Top module
 module tap_top #(parameter
@@ -106,7 +105,8 @@ module tap_top #(parameter
                 // 0100100101010001 part number (IQ)
                 // 00011100001      manufacturer id (flextronics)
                 // 1                required by standard
-                IDCODE_VALUE = 32'h149511c3)
+                IDCODE_VALUE = 32'h149511c3,
+                IR_LENGTH    = 4)
                (
                 // JTAG pads
                 tms_pad_i, 
@@ -166,6 +166,14 @@ input   debug_tdi_i;    // from debug mo
 input   bs_chain_tdi_i; // from Boundary Scan Chain
 input   mbist_tdi_i;    // from Mbist Chain
 
+//Internal constants
+localparam EXTEST         = 4'b0000;
+localparam SAMPLE_PRELOAD = 4'b0001;
+localparam IDCODE         = 4'b0010;
+localparam DEBUG          = 4'b1000;
+localparam MBIST          = 4'b1001;
+localparam BYPASS         = 4'b1111;
+
 // Registers
 reg     test_logic_reset;
 reg     run_test_idle;
@@ -463,18 +471,18 @@ end
 *   jtag_ir:  JTAG Instruction Register                                           *
 *                                                                                 *
 **********************************************************************************/
-reg [`IR_LENGTH-1:0]  jtag_ir;          // Instruction register
-reg [`IR_LENGTH-1:0]  latched_jtag_ir, latched_jtag_ir_neg;
+reg [IR_LENGTH-1:0]  jtag_ir;          // Instruction register
+reg [IR_LENGTH-1:0]  latched_jtag_ir, latched_jtag_ir_neg;
 reg                   instruction_tdo;
 
 always @ (posedge tck_pad_i or posedge trst_pad_i)
 begin
   if(trst_pad_i)
-    jtag_ir[`IR_LENGTH-1:0] <= `IR_LENGTH'b0;
+    jtag_ir[IR_LENGTH-1:0] <= {IR_LENGTH{1'b0}};
   else if(capture_ir)
     jtag_ir <= 4'b0101;          // This value is fixed for easier fault detection
   else if(shift_ir)
-    jtag_ir[`IR_LENGTH-1:0] <= {tdi_pad_i, jtag_ir[`IR_LENGTH-1:1]};
+    jtag_ir[IR_LENGTH-1:0] <= {tdi_pad_i, jtag_ir[IR_LENGTH-1:1]};
 end
 
 always @ (negedge tck_pad_i)
@@ -552,9 +560,9 @@ end
 always @ (posedge tck_pad_i or posedge trst_pad_i)
 begin
   if(trst_pad_i)
-    latched_jtag_ir <= `IDCODE;   // IDCODE selected after reset
+    latched_jtag_ir <= IDCODE;   // IDCODE selected after reset
   else if (tms_reset)
-    latched_jtag_ir <= `IDCODE;   // IDCODE selected after reset
+    latched_jtag_ir <= IDCODE;   // IDCODE selected after reset
   else if(update_ir)
     latched_jtag_ir <= jtag_ir;
 end
@@ -577,12 +585,12 @@ begin
   bypass_select           = 1'b0;
 
   case(latched_jtag_ir)    /* synthesis parallel_case */ 
-    `EXTEST:            extest_select           = 1'b1;    // External test
-    `SAMPLE_PRELOAD:    sample_preload_select   = 1'b1;    // Sample preload
-    `IDCODE:            idcode_select           = 1'b1;    // ID Code
-    `MBIST:             mbist_select            = 1'b1;    // Mbist test
-    `DEBUG:             debug_select            = 1'b1;    // Debug
-    `BYPASS:            bypass_select           = 1'b1;    // BYPASS
+    EXTEST:            extest_select           = 1'b1;    // External test
+    SAMPLE_PRELOAD:    sample_preload_select   = 1'b1;    // Sample preload
+    IDCODE:            idcode_select           = 1'b1;    // ID Code
+    MBIST:             mbist_select            = 1'b1;    // Mbist test
+    DEBUG:             debug_select            = 1'b1;    // Debug
+    BYPASS:            bypass_select           = 1'b1;    // BYPASS
     default:            bypass_select           = 1'b1;    // BYPASS
   endcase
 end
@@ -603,11 +611,11 @@ begin
   else
     begin
       case(latched_jtag_ir_neg)    // synthesis parallel_case
-        `IDCODE:            tdo_pad_o = idcode_tdo;       // Reading ID code
-        `DEBUG:             tdo_pad_o = debug_tdi_i;      // Debug
-        `SAMPLE_PRELOAD:    tdo_pad_o = bs_chain_tdi_i;   // Sampling/Preloading
-        `EXTEST:            tdo_pad_o = bs_chain_tdi_i;   // External test
-        `MBIST:             tdo_pad_o = mbist_tdi_i;      // Mbist test
+        IDCODE:            tdo_pad_o = idcode_tdo;       // Reading ID code
+        DEBUG:             tdo_pad_o = debug_tdi_i;      // Debug
+        SAMPLE_PRELOAD:    tdo_pad_o = bs_chain_tdi_i;   // Sampling/Preloading
+        EXTEST:            tdo_pad_o = bs_chain_tdi_i;   // External test
+        MBIST:             tdo_pad_o = mbist_tdi_i;      // Mbist test
         default:            tdo_pad_o = bypassed_tdo;     // BYPASS instruction
       endcase
     end
